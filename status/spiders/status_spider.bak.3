from scrapy.spider import BaseSpider
from scrapy.selector import HtmlXPathSelector
from scrapy.http import FormRequest
from scrapy import log

from status.items import StatusItem

import os
import inspect

# 3 debug levels, 3 being the most verbose
DEBUG = 2


"""
   Good test streets in Brooklyn are
   1) Everit St. { old fulton street <-> columbia heights}
"""


class StatusSpider(BaseSpider):
   name = "Boo Ya"
   allowed_domains = ["nyc.gov"]
   start_urls = [
                "http://a841-dotvweb01.nyc.gov/ParkingRegs/ViewController/LocationValidation.aspx"
    ]


   file_no = 1
   on_street = "POPLAR STREET"
   out_dir = "responses/"

   if DEBUG > 1:
      out_dir +=  on_street.replace(" ", "_")
      try:
         os.mkdir(out_dir)
      except OSError:
         log.msg(" debugging directory already exists.  Overwriting...")

   def set_viewstate(self, response, form_data):
      #print "I was called by %s" % inspect.stack()[1][3]
      hxs = HtmlXPathSelector(response)
      vs = hxs.select('//form/input[@name="__VIEWSTATE"]/@value').extract() 

      if (form_data['__VIEWSTATE']  == vs):
        print "function %s has the same view state as before" % inspect.stack()[1][3]
      else:
        form_data['__VIEWSTATE']  = vs

      ev = hxs.select('//form/input[@name="__EVENTVALIDATION"]/@value').extract() 
      form_data['__EVENTVALIDATION'] = ev
      form_data['__EVENTTARGET'] = ''
      form_data['__EVENTARGUMENT'] = ''
      form_data['__LASTFOCUS'] = ''


      if DEBUG > 2:
         self.log_response(response, self.file_no)
         self.file_no += 1
      return hxs
  
   def print_formdata(self, formdata):
      for (key, value) in formdata.iteritems():
         print "key (%s) --> %s" % (key, value)
      print "\n\n"

   def log_error(self, hxs):
      # check for errors
      if DEBUG == 2:
         errors = hxs.select('//div[@id="vsErrorMsg"]')
         for ul in errors.select('.//li'):
            log.msg( "errors: ", ul.extract())

   def log_response(self, response, step_no):
        # body 
        calling_fcn =  inspect.stack()[1][3]
        f = open(self.out_dir + "/body_" + calling_fcn + "_" +  str(self.file_no) + ".html", mode="w")
        f.write(response.body)
        f.close         
        

   def log_request(self, response, step_no):
        # requests
        r = open(self.out_dir + "/req_" + str(step_no), mode="w")
        r.write(response.request.body)
        r.close
        if DEBUG == 3:
            
            inputs = response.request.body.split('&')
            for input in inputs:
               print "\t--> %s\n" % input
       
    

   def step_one(self, response, formdata):
      """ Enter the 'on street' input and click on update cross streets """
      self.set_viewstate(response,formdata)
      # Set the "on street" input to the form
      formdata['iddOnstreet:txTextBox'] = self.on_street
      
      # issue a request to update the cross streets (button6 triggers a js function)
      return [FormRequest.from_response(response,
                        formdata=formdata, clickdata = {"name":"Button6"},
                        callback=lambda r: self.step_two(r, formdata))]
   
   
   def step_two(self, response, formdata):
      """Select the first cross street (from street) from the drop down.  Click submit in order to update the viewstate"""
      xpath_selector = self.set_viewstate(response, formdata)
      
      from_streets = xpath_selector.select('//select[@name = "iddFromstreet:ddlDropDown"]/option/text()').extract() 
      num_from_streets = len(from_streets) - 1
      print "STEP TWO: Found %d <from> streets for %s" % (num_from_streets, self.on_street)
      
      for option_value, from_street in enumerate(from_streets):
         # First option is "Select a street...."
         # Remove this from the list
         if option_value == 0 or option_value > 1:
            continue
         formdata['iddFromstreet:ddlDropDown'] = option_value

         yield FormRequest.from_response(response,
                            formdata=formdata,
                            clickdata = {"name":"Button7"},
                            callback=lambda r, f = from_street, d = formdata: self.step_three(r, f, d))
                            


   def step_three(self, response, from_street, formdata):
      xpath_selector = self.set_viewstate(response, formdata)
      self.log_response(response, self.file_no)
      self.file_no += 1
      to_streets = xpath_selector.select('//select[@name = "iddTostreet:ddlDropDown"]/option/text()').extract()

      # first option is "Select a street...", get rid of this
      if len(to_streets) == 0:
         print "STEP THREE: No 'to' streets for %s  " % (self.on_street)
         return

      # continue if there are cross streets
      n_to_streets = len(to_streets) - 1
      if DEBUG >= 1: 
         print "STEP THREE: Found %d <to> streets for <from> street %s" % (n_to_streets, from_street)
         print "STEP THREE: cross streets for (from_street) %s : %s " % (from_street, to_streets)

      for (option_value, to_street) in enumerate(to_streets):
         if option_value == 0 or option_value > 1 : 
            continue
         formdata['iddTostreet:ddlDropDown'] =  option_value
         
         yield FormRequest.from_response(response,
                        formdata=formdata, 
                        clickdata = {"name":"Button7"},
                        callback=lambda r, f = from_street, t = to_street: self.step_four(r, f, t)) 
                        #callback=lambda r, d = formdata, f = from_street, t = to_street, o = option_value: self.step_three_and_half(r,d, f, t, o))




   def step_four(self, response, from_street, to_street):
      #self.log_request(response, (self.file_no * 10))
      self.log_response(response, self.file_no)
      self.file_no += 1
      hxs = HtmlXPathSelector(response)


      #from_street = hxs.select("//select[@id = 'iddFromstreet_ddlDropDown']/option[@selected = 'selected']/text()").extract()
      the_to_street = hxs.select("//select[@name = 'iddTostreet:ddlDropDown']/option[@selected = 'selected']/text()").extract()
      print "This is the to street %s" % the_to_street

      # The regulation results are in a table with id "GridView1"
      found_regs = hxs.select('//table[@id = "GridView1"]/tr')
      n_regs = len(found_regs) - 1
      if DEBUG >= 1: print "STEP FIVE: Found %d regulations for %s AND %s" % (n_regs, from_street, to_street)

      for row in found_regs:
         # The regulation id is a hyperlink with a 'onclick' call, so just grab the text
         reg_no = row.select(".//a/text()")
         if len(reg_no) == 0:
            continue
         # The reg list will contain column values
         # e.g. [Regulation Info,Side, On Street, From Street, To Street]
         reg = StatusItem(regulation = reg_no.extract())

         # For some reason, cannot grab the text directly that's encapsulated by <font> tags
         rest =  row.select(".//td/font/text()").extract()
         reg['side'] = rest[2]
         reg['onStreet'] = rest[3]
         reg['fromStreet'] = rest[4]
         reg['toStreet'] = rest[5]

         yield reg

   
   def parse(self, response):
      """ The main method for scrapy.  Begin the scraping here
         """
      formdata = { 'ddlOnBoro': 3, '__VIEWSTATE' : "" }
      self.set_viewstate(response, formdata)

      print "Searching for regulations around %s" % self.on_street
      
      # print "the form data %s " % self.form_data
      return FormRequest.from_response(response,
                        formdata=formdata, clickdata = {"name":"Button7"},
                        callback=lambda r: self.step_one(r, formdata))
